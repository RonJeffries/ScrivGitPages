<?xml version="1.0" encoding="UTF-8"?>
<SearchIndexes Version="1.0">
    <Documents>
        <Document ID="6ED67C14-CB4A-4CF0-AF1B-3D66175353A4">
            <Title>Image References Fail</Title>
        </Document>
        <Document ID="A097259C-FE0E-410F-BC53-AE376D2AAD86">
            <Title>Another couple of paragraphs</Title>
            <Text>This is being written in a second sub-document, called “Another couple of paragraphs”. The Scrivener binder looks like this:

#

This should be enough to let us see whether our sections are working right. Let’s look at the compile:</Text>
        </Document>
        <Document ID="DB77D1DC-5E76-4D69-8045-874C95D0146D">
            <Title>Creating the ToC</Title>
            <Text>I think the remaining priorities for this little effort are the table of contents, and setting it up to be fully automated. By “fully”, I mean that issuing a compile should automatically run the Ruby script that creates our individual files, plugs in the links, and creates the table of contents. I probably will not go so far as to automate the git commit and push to GitHub. We’ll see.

Since creating the table of contents requires some file-mangling, I think I’ll start with that before automation, so that I don’t have to wipe out the files that are currently up on GitHub. They’re under Git, so I could get them back, but let’s just not destroy them. So, table of contents first.

The approximate plan is to replace my hand-made ToC with a marker, probably \&lt;—TOC—&gt;, in the source file. Then the Ruby script can just split the index file on the marker, write out the first chunk, write out the ToC, then write out the second chunk. Should be really “easy”. 

I guess first, I’ll make the ToC edit and recompile. For my own convenience, I’ll comment out the existing one, in case everything goes wrong. … OK, that’s done.

The main loops of the Ruby script look like this:

```ruby
input = ARGF.read
chunks = input.split(SPLIT_MARKER)
reference_chunk = chunks.delete_at(-1)
filenumber = 0
chunks.each do | chunk |
  title = chunk.split("\n")[0]
  Titles[filenumber] = title[2..-3]
  filenumber += 1
end
filenumber = 0
chunks.each do |chunk|
  write_file(chunk, reference_chunk, filenumber, chunks.length - 1) unless chunk.length &lt; 1
  filenumber += 1
end
```

(We should factor out those two loops, by the way, calling one `get_titles` and the other `write_files` or something. Maybe later.) Anyway, we’ve already pulled one chunk off the back of the list before proceeding. What if we pull the one off the front and process it? We could either write it out separately, or we could assemble a new chunk, with the ToC in it, and put it back. I’m inclined to the latter.

Why? Two reasons. First, I expect it involves less changing of existing code. Second, I’d have to duplicate at least the call to write_file, and possibly even create a new version of that function. I could be wrong. We’ll see what happens as I go along. First things first, I’ll pull out the chunk and edit it trivially and put it back.

Here’s what I’ve got now, the main and the `add_toc` function:

```ruby
input = ARGF.read
chunks = input.split(SPLIT_MARKER)
reference_chunk = chunks.delete_at(-1)
toc_chunk = chunks.delete_at(0)
updated_toc = add_toc(toc_chunk)
chunks.insert(0, updated_toc)
filenumber = 0
chunks.each do | chunk |
  title = chunk.split("\n")[0]
  Titles[filenumber] = title[2..-3]
  filenumber += 1
end
filenumber = 0
chunks.each do |chunk|
  write_file(chunk, reference_chunk, filenumber, chunks.length - 1) unless chunk.length &lt; 1
  filenumber += 1
end

def add_toc(chunk)
  halves = chunk.split(TOC_MARKER)
  puts "halves length %d" % halves.length
  return chunk if halves.length != 2
  return halves[0] + "\nHERE IT IS\n" + halves[1]
end
```

That’s doing exactly what I expected, removing my TOC flag, and inserting “HERE IT IS” where the ToC should go. There was one little glitch: when I first ran it, the add_toc function wasn’t finding the flag. Turns out, Scrivener, or MacOS in their zeal to be helpful, had converted -- to —, the em-dash. Thanks, doll. 

Now all I have to do is format the ToC and insert it. Life is good.

Silly boy! You can’t put the real ToC in until *after* you’ve created the Titles Hash. Here’s what I’ll try now.

```ruby
input = ARGF.read
chunks = input.split(SPLIT_MARKER)
reference_chunk = chunks.delete_at(-1)
filenumber = 0
chunks.each do | chunk |
  title = chunk.split("\n")[0]
  Titles[filenumber] = title[2..-3]
  filenumber += 1
end
toc_chunk = chunks.delete_at(0)
updated_toc = add_toc(toc_chunk)
chunks.insert(0, updated_toc)
filenumber = 0
chunks.each do |chunk|
  write_file(chunk, reference_chunk, filenumber, chunks.length - 1) unless chunk.length &lt; 1
  filenumber += 1
end
```

That works! Here’s what add_toc looks like now:

```ruby
def add_toc(chunk)
  halves = chunk.split(TOC_MARKER)
  puts "halves length %d" % halves.length
  return chunk if halves.length != 2
  return halves[0] + table_of_contents + halves[1]
end

def table_of_contents
  toc = ""
  Titles.each_pair do | number, title |
    toc += "* [" + title + "](" + make_file_name(number) + ")\n"  
  end
  return toc
end
```

That could be cleaner. I’ll do a little cleanup and then push this baby.

First, I improve this:

`toc += "* [" + title + "](" + make_file_name(number) + “)\n”`

to this:

`toc += "* [%s](%s)\n" % [title, make_file_name(number)] `

That’s a bit more like Ruby. Now I want to factor out all the loops and other chunks, using the Composed Method pattern, which essentially asks that a method either do things, or call things, but not both. 

That goes swimmingly (which, I gather from extensive reading, means “well”), and now the main looks like this:

```ruby
input = ARGF.read
chunks = input.split(SPLIT_MARKER)
reference_chunk = chunks.delete_at(-1)
record_titles(chunks)
update_table_of_contents(chunks)
write_files(chunks, reference_chunk)
```

That’s nearly good, in my opinion. Below is the whole script, in case you want to read it or use it as it stands. I’m going to go remove the saved ToC from the top of the booklet, generate, and ship.

Next step, maybe: work on running the script right out of Scrivener. I think this is nearly ready to go.

```ruby
#!/usr/bin/env ruby -wU
require 'tempfile'

SPLIT_MARKER = "----\n\n"
TOC_MARKER = "&lt;!--TOC--&gt;\n"
Titles = {}

def add_toc(chunk)
  halves = chunk.split(TOC_MARKER)
  puts "halves length %d" % halves.length
  return chunk if halves.length != 2
  return halves[0] + table_of_contents + halves[1]
end

def make_file_name(filenumber)
  return "index.md" if filenumber == 0
  return sprintf("%02d.md", filenumber)
end

def make_link_line(filenumber, max_length)
  link = ""
  # if ( filenumber == 1 ) 
    # link += "[Prev](index.html) "
  if filenumber &gt; 0
    link += "[%s](%02d.html) | " % [Titles[filenumber - 1], filenumber - 1]
  end
  link += "[Top](index.html) | "
  link += "[%s](%02d.html)" % [Titles[filenumber + 1], filenumber + 1] unless filenumber &gt;= max_length
  return link
end

def record_titles(chunks)
  filenumber = 0
  chunks.each do | chunk |
    title = chunk.split("\n")[0]
    Titles[filenumber] = title[2..-3]
    filenumber += 1
  end
end

def table_of_contents
  toc = ""
  Titles.each_pair do | number, title |
    # toc += "* [" + title + "](" + make_file_name(number) + ")\n" 
    toc += "* [%s](%s)\n" % [title, make_file_name(number)] 
  end
  return toc
end

def update_table_of_contents(chunks)
  toc_chunk = chunks.delete_at(0)
  updated_toc = add_toc(toc_chunk)
  chunks.insert(0, updated_toc)
end

def write_file(chunk, reference_chunk, filenumber, max_length)
  filename = make_file_name(filenumber)
  title = Titles[filenumber]
  puts filename + ": " + title
  tf = File.new(filename, "w")
  tf.print chunk
  tf.puts
  tf.puts
  tf.puts make_link_line(filenumber, max_length)
  tf.puts
  tf.puts
  tf.print reference_chunk
  tf.puts
  tf.puts
  tf.close
end

def write_files(chunks, reference_chunk)
  filenumber = 0
  chunks.each do |chunk|
    write_file(chunk, reference_chunk, filenumber, chunks.length - 1) unless chunk.length &lt; 1
    filenumber += 1
  end
end

input = ARGF.read
chunks = input.split(SPLIT_MARKER)
reference_chunk = chunks.delete_at(-1)
record_titles(chunks)
update_table_of_contents(chunks)
write_files(chunks, reference_chunk)
```</Text>
        </Document>
        <Document ID="D032EF51-C099-42E4-94FF-326820D6DBB0">
            <Title>Sections</Title>
            <Synopsis>Set up the document and folder levels we like.</Synopsis>
            <Text>Next, I’m going to set up my “book” chapter and section information. I have in mind a very simple structure: A document at the top level of Scrivener’s binder, like this one, will be a “chapter”, represented as a single GitHub page. In principle, that would be all you need.

However, Scrivener has this really nice cork board feature, where you can put virtual index cards down, each one representing a document, with the document title, and a synopsis, where you can write on the card what a proposed document will be about. You can see the card for this document in the top right of this picture:

#

Because I plan to use the cork board to organize this little book, I want to allow for a bit more structure than just documents at the top. I’d like to organize a few cards into a chapter, so my rule will be that a folder at the top level also represents a chapter, and documents inside that folder represent text inside that chapter. So, if a chapter has three ideas in it, there might be three cards representing those ideas, and then each card’s document would  have some paragraphs about that idea. 

Why do we care? Well, we’re getting ahead of ourselves a bit, but I have learned enough about Scrivener’s compile to think that I’d like my chapters, when compiled, to automatically include the chapter Title from the binder, as their heading. But for ideas within the chapter, I expect not to include the card title, instead leaving the idea transition and any subtitling to manual editing.

I could do all the titling manually, and in the end I may prefer that. But I’m trying to give Scrivener every chance to work for me, so I’m planning to use that much structure.

Let’s talk about how that has to be set up.</Text>
        </Document>
        <Document ID="C334B2C7-DC05-4275-875E-A6A46C3B0F50">
            <Title>TL;DR</Title>
            <Text>For those who don’t want to follow along all my missteps and wander down the dead ends of my learning, let me sum up here how my Scrivener is set up.</Text>
        </Document>
        <Document ID="D9D8AE2C-4173-401A-AFBC-BD4FAAEDBF9D">
            <Title>Compile Format Details</Title>
            <Text>Double-clicking my format, we can start looking at the details:

### Section Layouts

#
￼

In section layouts there’s really nothing special on the initial page, and none of the other tabs have anything changed in them.

￼

I have it adding closing hashes to titles, which is, I believe, the default.

### Separators

I’ve overridden the default separators on Folders and Text Files in my layouts. The ones I actually use are called “Use” this and that:

￼￼

It turns out that these settings are important. Section break, in the top one, inserts the default page separator, four dashes, that my splitter script searches for. It would be possible to put in a more unique separator, as AmberV’s example, referenced elsewhere, does. 

The three other sections are experimental and I won’t trouble you with them.

### Text Layout

￼

This one puts a separator at the end of the document, namely ahead of the magic references links that my splitter script looks for. If I didn’t include this, it would be difficult for splitter to find and break off the references, which we insert into every page we split out.

### Processing

￼

Here’s where we put the link to our Ruby splitter script, which divides up Scrivener’s big output file into the smaller files we want for GitHub pages. The path has to be a legitimate path to the file. The operating system $PATH or equivalent variables are not interrogated. 

The arguments will automatically include the name of the output file, and the script will be running in the Scrivener output folder. The `&gt; test.txt` is there so that I can see what happened during the run of splitter. Generally I don’t look.

</Text>
        </Document>
        <Document ID="470FEA0D-E7C5-47D0-914F-5050B859654D">
            <Title>Auto Titles in Subs</Title>
            <Text>### Auto Titles in Subs

Relatedly, I’m typing titles fairly often in some of these parts of the project that are in folders. Since I include titles automatically in my top level layout, and since I’m using them often in the lower level, this, too is evidence that I need a deeper structure, and perhaps automatic titles all the way down, or most of the way down.

I’ll evolve that as I go on with other writings.</Text>
        </Document>
        <Document ID="D8CABE06-B45B-48F9-B1ED-6CAFFB9CECBE">
            <Title>Random Settings</Title>
            <Text>### Some random information about settings lest I forget

View &gt; Text Editing &gt; Show Titles in Scrivenings

Related Options in Scrivener Preferences (command comma)

#

Note especially “Do not show separators above titles”. Uncheck to get separators plus titles. I prefer that.</Text>
        </Document>
        <Document ID="D99E8C1C-6268-42A3-A90C-14688B5A202B">
            <Title>Publish what we've got</Title>
        </Document>
        <Document ID="5C2B0B1F-511B-4EFA-A7F9-4E2C3B0026F8">
            <Title>Compile and Folders</Title>
            <Text>That url, with /v20180615.md/v20180615.html, is what I had to use because of how Scrivener does a compile of an MMD, it needs to export all your pictures, and all your text, into the same folder. And the compile window has only one name field in it, so they create a folder with the name you give, and a markdown .md file of the same name, and then when GitHub compiles the site, you get that name with .html instead of .md. Thus the odd name.

Now what I’d *like* would be to have a folder name like `v20180615`, and the file name index.md, so that the URL could be something like `ronjeffries.github.io/v20180615/` and the implicit lookup for index.html would do the rest. So I looked in the manual and asked on the excellent Scrivener forum. Soon I got the answer, which was so odd and incredible that it took me four tries to understand and believe it. Hold on.

If the folder you compile into happens to have a name ending in `_mmd` or `-mmd`, then the name you put in the compile window, like `index.md` will be applied to the output file only. No subdirectory will be created, and all the files will just dump into your `_mmd` folder. This bizarre fact is actually documented, on page 530 of the Scrivener manual.

But wait, there’s more. 

#

Normally when MMD is compiled, I guess, they clear the folder and then fill it. Apparently that checkbox in the dialog above ensures that any other files in the folder are left alone: only the ones Scrivener creates are overwritten. The description of this seems to say that the _mmd trick also avoids the overwriting, and that setting the checkbox may write to the parent folder. It’s very confusing. I expect to destroy the GitHub pages at least once because of this.

However, what this suggests to me is that I can get a shorter URL for these early draft copies using the _mmd trick. I’ll try that right now, hoping to create this version right here. And before I do that, I’ll put a version marker at the very top of the book. Then I’ll compile it and push a copy. 

That works and it’s preserved at [https://ronjeffries.github.io/scriv-git-pages/v20180616_mmd/](https://ronjeffries.github.io/scriv-git-pages/v20180616_mmd/)</Text>
        </Document>
        <Document ID="CF0E92DB-ED74-4B35-8413-CD4ECE664CEB">
            <Title>Documents, Sections, Layouts</Title>
            <Text>Warning: I’m going to get the terms wrong here, but I’ll do my best to correct to Scrivener terms.

Each document in Scrivener is a “Section” and has a “Section Type” for compilation. Associated with each Section Type, there is a “Layout”, which tells Scrivener how to format the compiled output for that section. We’ll use that to control what comes out, to be fed into GitHub Pages.

You could do this incrementally, or later, but I think it’s best to set up our initial Section Types now. We’ll have two, initially, which I think I’ll call Section, and Sub-Section. We’ll set them up to be auto-assigned: top level documents and folders will get Section, documents at the next level down will get Sub-Section.

You set this up in Project &gt; Project Settings, in the Sections tab:

#

I’ll use the plus and minus buttons to create mine:

￼

Then we go over to Default Types by Structure to tell Scrivener about our folders and sub-documents. It starts like this:

￼

That’s not what we want, quite. We’ll use that +levels button to provide more levels for files, and fill that in:

￼

I think that should do the job for us. Root files is like where Scrivener’s Draft and Research folders are. Level 1 is documents like this, and Level 2 will be documents inside folders. 

We’ll worry about layouts pretty soon. I want to think a bit now about what else to put in this little book, and how to organize it. I may even be regretting the simplistic section layouts we just did, but I know it’s easy to change.</Text>
        </Document>
        <Document ID="1B350B73-9AB8-4696-8AEF-A910C99017B1">
            <Title>Introduction</Title>
            <Text>Version &lt;$shortDate&gt; &lt;$shortTime&gt;

Recent Changes: 

Thoughts on Improvements - maybe in the future

Forum Links - forum topics relating to this booklet

TL;DR - summarizes settings changes

### Table of Contents

&lt;!--TOC--&gt;

### Welcome

Welcome to scriv-git-pages! This is a little book about how to use Scrivener to produce a little book on GitHub Pages.

I have had and admired the Scrivener app for a long time, and always wanted to write something using it. I’ve tried it a few times for NaNoWriMo, National Novel Writing Month, to some good effect but ultimately no novel. I’ve tried it for a few other efforts, and right now I’m using it to write another little book that you’ll never see.

Scrivener, as I understand it, was created for writing books. It is focused on producing a single integrated output for various publication formats, eBook, PDF, I don’t know what all. It’s very powerful and, though it is well organized, it is incredibly complex because of all that power. 

I mostly write web pages. If I were to publish one of those would-be novels, it would probably be on Leanpub, which expects separate chapters in separate files. Scrivener was not built for that purpose and its author doesn’t want to make it fit that purpose. Well, his house, his rules. 

Nonetheless, some of Scrivener’s users have found ways to do these things, and I really want to use it in a project, so I’m going to build on the ideas of others and figure out a way that works for me. Since I’m doing another project using GitHub Pages, and since Scrivener really is a complex beast, I had decided to document all my settings and approaches. Then it occurred to me to publish them. That will encourage me to be more complete and clear, and it may, I hope, be useful to others.

Here goes!</Text>
        </Document>
        <Document ID="482558E5-8113-4800-B8C8-E23790F2765C">
            <Title>Looking at compile</Title>
            <Text>Just for grins, this is yet another sub-document, called Looking at compile. Here’s what the compile window looks like now:

#

Notice that the sub documents in the folder are called Sub-Section, just as we intended. That happened automatically, because of that structure setup we did. You can see that the Section Types are all shown in italic. That means they were automatically defined from structure. We could set them explicitly if we wanted to. But we don’t. I *would* like to see what the compiled text looks like right now, so I’ll let the compile go through.</Text>
        </Document>
        <Document ID="34613D57-BC96-440A-95BB-47386CA00336">
            <Title>Publish what we've got</Title>
            <Text>Let’s go for it! Let’s publish what we have right now, and put it in a page with a known name, which we’ll retain for historical purposes. (I wonder if anyone will ever read this. A conversation yesterday tried to assure me that my mission is to emit my own behavior and not worry about whether other people find it useful. Years of Irish Catholic upbringing, however, make that hard to do.

Thinking out loud here, I believe we’ll do two things. First, we’ll compile this, as is, to a convenient name like v20180615.md, namely today’s date. Then we’ll update the README, for now. Then, we’ll create an index file, etc., as time goes on.

It actually went up, and if you want to look at it, it’s at [https://ronjeffries.github.io/scriv-git-pages/v20180615.md/v20180615.html](https://ronjeffries.github.io/scriv-git-pages/v20180615.md/v20180615.html). Of course, you won’t know to look until we get things at least a bit better arranged. I’ll leave that file there, but a story goes with it.

</Text>
        </Document>
        <Document ID="BFFD3C34-BF32-4249-8B13-22AE3647D312">
            <Title>Default Formatting</Title>
            <Text>You set your initial font and paragraph info in Scrivener &gt; Preferences, (command-comma). My info looks like this:

#

To change that information, you can click the controls at the top of the paragraph, for example, to show the fonts panel:

￼

I could change the face from Arial if I wanted to. I don’t. I am going to turn off the Show Invisibles, however.

Note in the Formatting window above that the two paragraphs, the quotation and the name, are adjacent. When you’re on that window, you could use Format&gt;Paragraph&gt;Line and Paragraph Spacing to put some inter-paragraph spacing in place. I don’t do that, because Markdown requires explicit blank lines between paragraphs, so making fake ones would just confuse me. If this paragraph confuses you, pretend you didn’t read it.</Text>
        </Document>
        <Document ID="D7EC6D12-8C21-451C-9EFE-6E3335503E73">
            <Title>Splitting</Title>
            <Text>I think it’s time to start splitting up the files. I’ll publish a few more versions, or maybe subsets, as I do this, in case anyone is watching, and for historical purposes (that is, because I want to). But the main thrust will be to try to get a published multi-page version onto GitHub Pages ASAP.

To that end, I think I’ll just split this one big file into one file per section, and name them 01,02, and so on. That should be a simple-enough script.

The first thing is to get Scrivener to put a separator string between our files. It turns out that it knows how to do this. To do so, you need to be using your own output format, not one of the defaults. You begin by popping up a menu on the one to change (I’ve picked Default, since it’s what I’ve been using so far) and you get a copy. You can see Default Copy is already there, since I’ve already created my copy. 

#

Next step, we’ll edit this and give it a better name, RJ GitHub. And we get the message that it has no assigned layouts. I guess those aren’t copied. I’ll go through that process again, as described above.

Now it turns out, I’m not sure how it happened, this new compile format is creating separators between the sections already, using four dashes, which makes for a horizontal rule in the displayed HTML:


￼

Doubtless because of the layouts I picked, it’s doing it between Sections and not between Sub-Sections, which is just right. This could be good enough to start with, and I think I will. 

I’m going to copy the `index.md` file somewhere safe and see about splitting it.

First attempt, I tried the Bash command `csplit`. I could get it to do the splitting but it seems not to have a feature to skip the separator line, instead putting it in the next file created. Let’s just bite the bullet and do some Ruby. 

We’re in luck, because AmberV (Ioa Petra'ka) of the Scrivener forum has already created an example we can copy. Here’s a link to [the article.](https://www.literatureandlatte.com/forum/viewtopic.php?f=2&amp;t=52114&amp;p=266283#p266283).

Here’s Ioa’s version:

```ruby
#!/usr/bin/env ruby -wU
require 'tempfile'

SPLIT_MARKER = '&gt;&gt;&gt;&gt; '
FILE_EXTENSION = 'tex'

# Split the input file by markers, writing the contents into temp files. Access temp file with file_chunk['name_of_file.txt']
file_chunks = {}
metadata_block = nil
input = ARGF.readlines
input.join.split(SPLIT_MARKER).each do |chunk|
  # Store the first chunk as MMD metadata, to be added to each temp file
  unless metadata_block
    metadata_block = chunk
    next
  end
  next if chunk.length &lt; 1

	filename, *lines = chunk.split("\n")
	next if filename[-4..-1] != ".#{FILE_EXTENSION}"
	tf = Tempfile.new(filename)
  # Add metadata to top of each temp file; unless we're in the reference list
  tf.print metadata_block unless filename == "references.#{FILE_EXTENSION}"
  tf.print lines.join("\n")
  file_chunks[filename] = tf
end

# Pull out the references.txt temp file. We will append it to the bottom of each document that we process. It contains figure and footnote references. Pandoc will ignore any that do not apply to the section, so this can be done blindly.
references = file_chunks.delete("references.#{FILE_EXTENSION}")
file_chunks.each_pair do |filename, tmpfile|
  references.rewind
  tmpfile.print references.readlines.join("\n")
  tmpfile.close
  `multimarkdown -t latex -o #{filename} #{tmpfile.path}`
end
```

I’m going to immediately rip all the fancy stuff out of that, to build up a test script. After more trouble than I’d care to admit, I get this:

```ruby
#!/usr/bin/env ruby -wU

SPLIT_MARKER = "----\n\n"

filenumber = 0
input = ARGF.read
input.split(SPLIT_MARKER).each do |chunk|
  next if chunk.length &lt; 1
  title = chunk.split("\n")[0]
  if filenumber == 0
    filename = "index.md"
  else
    filename = sprintf("%02d", filenumber) + ".md"
  end
  filenumber += 1
  puts filename + ": " + title
	tf = File.new(filename, "w")
  tf.print chunk
  tf.close
End
```

That produces this output:

```

index.md: # Introduction #
01.md: # Style, Scrivener's and Mine #
02.md: # ToC and Pages #
03.md: # Starting the Project #
04.md: # Default Formatting #
05.md: # Styles #
06.md: # Sections #
07.md: # Documents, Sections, Layouts #
08.md: # Regrets, I've had a few #
09.md: # Testing the Compile #
10.md: # Setting up the project #
11.md: # Appendices #
```

And it produces these files:

```Widebody2:ScrivGitPagesScratch ron$ ls
01.md		04.md		07.md		10.md		pages.md
02.md		05.md		08.md		11.md		splitter.rb
03.md		06.md		09.md		index.md
```

That’s just what I had in mind. Note in the above that since I wanted to *produce* `index.md`, I changed the name of the original `index.md`, containing everything, to `pages.md`. We’ll need to remember to do that in our compilations, of course.

I’m not particularly proud of this Ruby code, as my Ruby is quite rusty, but in case you’re even more rusty, here’s what it does:

1. The script accepts a file name on the command line. I give it `pages.md`. It reads in that file as one big string. Then it splits the file on the string `—-` followed by two newlines, because that’s what happens to be produced by Scrivener. It has double spaced before and after the four dashes. The Ruby `split` method splits on exactly the characters you give it, not on lines, so my files all had a couple of newlines at the front. That would be harmless to Jekyll, but I know I want the title for table of contents creation.
2. We loop over each chunk of the file.
3. We extract the first line, which will be the Section title.
4. If the file number is zero we use the output file name `index.md`, otherwise we use the two digits of filenumber, `01.md`, `02.md`, and so on. 
5. We print the file name and title, so I can see what’s going on.
6. We write the chunk to the file.

All this seems to be working. 

Constant readers of my work may be asking themselves, Jeffries, where’s the TDD? Where’s the design? Where are the classes and methods, the clean code?

Those are good questions. My answer, basically, is that this is a bit of a “Spike”, and I don’t generally TDD a Spike unless I’m trying to learn and document something in the system. I’m going to have a moral decision to make as we go forward, whether to set this splitter up with tests, whether to refactor it, or just to let it be a conventional script. 

I’m interested to find out what I do, and I hope you are, too. But our main purpose here is to show how to get to GitHub pages, and we’ll focus on that. 

I did this in a scratch folder. But I think that if I were to copy index.md and its friends into the root of my ScrivGitPages project and push it, I’d actually have pages to display. Ah … I’d need to copy up all the picture files as well, of course. I think I’ll just do that and we’ll see what happens. 

To get as close as possible to the right result, I’ll compile a new version, including these last lines here, into my scratch folder, run the program, move things, and push. 

If this works, [https://ronjeffries.github.io/scriv-git-pages/](https://ronjeffries.github.io/scriv-git-pages/) should contain the index file, and I’ll hack a table of contents in by hand for now. If you’re reading this, it worked.



</Text>
        </Document>
        <Document ID="4201CF88-19BC-40CC-B3B3-37D2B1B9979B">
            <Title>Starting the Project</Title>
            <Text>We’re here to create a little “book”, showing how to create the GitHub pages you will be reading when this is all done. This chapter starts at the beginning, though it may not wind up being the first page of the “book”.

I’ve just started with a blank Scrivener project, which I named “GitHub-Pages” and saved in Dropbox/Apps/Scrivener, where my shared Scrivener projects live.

Right now, what I see on the screen looks like this:

#

I’ve got View &gt; Text Editing &gt; Show invisibles turned on right now. That’s making the paragraph markers and dots for spaces show up. I don’t usually have that on but wanted to talk about the defaults set so far.

I’m going to compile from Scrivener to MultiMarkdown, which is its compile form intended to produce, well, MultiMarkdown, which will be roughly what GitHub expects to make our pages. And although Scrivener lets you format your typing any way you like, and although we may play with that capability later on, I’m used to typing in a sans-serif font (presently Arial) with explicit returns between paragraphs. I’ve got Scrivener’s default formatting set up that way.</Text>
        </Document>
        <Document ID="DB5FA5F9-1200-4ECC-92CD-D47750CC51D5">
            <Title>Image References Fail</Title>
            <Text>In all the excitement, I didn’t mention above that there was a problem with my references to images. I fixed them up by hand in the previous release. The problem is this:

When you put an image into a Scrivener document, you just drag it in, and there it goes. It compiles correct MultiMarkdown for it automatically, as part of the MMD compilation features. If you’ve dragged in `image_file_name.png`, for example, it compiles:

`\![][image_file_name]`

right in place, and then at the very end of the compile, it compiles in the reference definitions, in this case:

`\[Image_file_name]: image_file_name.png`

Now, I’d have preferred it to compile the image into one line:

`\![](image_file_name.png)`

Anyway, it doesn’t. I’ve asked if there’s a way to set it to compile that way, or at least put the reference line right near the image line but I’m expecting no joy on that. And had I read AmberV’s solution, referenced above in *Splitting*, more carefully, I’d have seen how it was handled there. I’ll edit in a link to the writeup on the Scrivener forum in that chapter, in case you want more information.

Note: That will perhaps be the first external reference I’ve put into this booklet, and it may suffer from the same fate as images, or some other fate. We’ll see. If so, another learning experience and another section for the booklet.

We’ll do a version of Amber’s solution, but more consistent with the somewhat simpler approach in my Ruby program. Right now, it just assigns the file names numerically, except that the first file is named `index.md` rather than `00.md`, to make a home page for GitHub Pages. Because I’m using the default separator line, `——` and because Scrivener just dumps the references at the end without a separator, I’ll have to either go to using a file “suffix”, or use some other hack to make sure I can identify the final file.

Then, we’ll copy AmberV’s trick, which is just to append that file to each of the others, so that each one knows all the references. That’s redundant, but harmless: the translator doesn’t use any references it doesn’t need. (Or so we are led to believe.)

AmberV’s solution includes a file name in each separator, and there is a special one hammer’d in at the end of the file. There’s a document suffix you can supply, in this option in the compile format:

#

AmberV uses a hand-crafted version of the standard separator. We could just put in our simpler one, and then use that file separately on the basis of it being last. The script keeps all the files open until the end, saving them in a dictionary, then when the references finally show up, loops over all the other files and appends the references to the end of each one and closes it. Perfectly reasonable solution.

I’m not sure what approach I’ll take just now. I’ll work on that over the next few sessions. With any luck it should only take one session. Maybe tomorrow.

A small issue is that I really don’t want to publish a version until the images are fixed. It’s a bit of a pain fixing them by hand. Well, let’s say that I’ll publish tomorrow, one way or the other. Agreed? Thanks.</Text>
        </Document>
        <Document ID="96E3BF26-D9C3-4111-9CD6-489624FF41F5">
            <Title>Intro</Title>
            <Text>I’m just noting here odd snippets of information and events, so that they won’t be entirely lost. I hope I’ve recorded everything above but I’ll leave these just in case.</Text>
        </Document>
        <Document ID="9B802FDC-AB37-431F-9152-8803B34D90D2">
            <Title>We need a project</Title>
            <Synopsis>Start setting up GitHub</Synopsis>
            <Text>If this is going to be about creating GitHub Pages in Scrivener, we’re going to need a GitHub project. Let’s set that up. We’ll call it scriv-git-pages, and make it public in case anyone ever reads this.

That’s done, and I’ve cloned the project to a folder in my Dropbox. Now we need to set up Pages. I think you do that in GitHub settings:

#

We need to decide whether to put this whole project in GitHub Pages or just the docs folder. I guess we’ll do the whole thing, since the whole project probably should be public. It’s set up and working.  The site address is [https://ronjeffries.github.io/scriv-git-pages/](https://ronjeffries.github.io/scriv-git-pages/). It looks like this:


￼

A little research tells me that GitHub Pages will put the README.md as the home page of the site, *unless* you have an *index.md* file, in which case it’ll be used.</Text>
        </Document>
        <Document ID="0A1E9D93-7934-4403-8BFE-39B7A4593665">
            <Title>Refactoring First</Title>
            <Text>OK, our issue is that Scrivener puts references, including images, at the end of the whole document. When we split the document into multiple files, one per section, each section needs to have those references at its end, or its images won’t link up.

So our mission, and we do wish to accept it, is to strip out the references from the end, and copy them onto the end of every output file before we close it. My cunning plan is roughly this:

1. Put a separator at the end of the document, so that the last chunk we split out is the references section.
2. Remove that section from the array of chunks, so that we don’t put it out as a separate file,
3. But *do* append it to each of the other files.

If you look at AmberV’s script, this is accomplished by saving the section’s titles and file handles in a Hash, and then looping over them, appending the reference section to each. My script doesn’t have the section titles, but I think I can accomplish much the same thing by saving the file handles in an array.

The big moral decision here is whether to clean up this script first. Here it is:

```ruby
#!/usr/bin/env ruby -wU
require 'tempfile'

SPLIT_MARKER = "----\n\n"

filenumber = 0
input = ARGF.read
chunks = input.split(SPLIT_MARKER)
# puts "Chunks length %d" % chunks.length
chunks.each do |chunk|

  next if chunk.length &lt; 1
  title = chunk.split("\n")[0]
  if filenumber == 0
    filename = "index.md"
  else
    filename = sprintf("%02d", filenumber) + ".md"
  end
  puts filename + ": " + title
  tf = File.new(filename, "w")
  tf.print chunk
  link = ""
  if ( filenumber == 1 ) 
    link += "[Prev](index.html) "
  elsif filenumber &gt; 1
    link += "[Prev](%02d.html) " % (filenumber - 1) unless filenumber == 0
  end
  link += "[Top](index.html) "
  link += "[Next](%02d.html)" % (filenumber + 1) unless filenumber &gt;= chunks.length - 1
  tf.puts
  tf.puts
  tf.puts link
  tf.close
  filenumber += 1
end
```

That’s pretty awful. I think I need to do at least a little cleanup before making it worse. Without a pair, though, and without tests, I hesitate to go too far. I’ll try a bit of cleanup,  however. I should probably really create a class and call it but I’m going to hold off on that, simply because I’m rusty and more confident pulling out some functions. First, let’s go after creating that link line, which should be pretty simple. (Hold my beer.)

Ha! How could you doubt me? How could I doubt me? This worked, the first time:

```ruby
#!/usr/bin/env ruby -wU
require 'tempfile'

SPLIT_MARKER = "----\n\n"

def make_link_line(filenumber, max_length)
  link = ""
  if ( filenumber == 1 ) 
    link += "[Prev](index.html) "
  elsif filenumber &gt; 1
    link += "[Prev](%02d.html) " % (filenumber - 1) unless filenumber == 0
  end
  link += "[Top](index.html) "
  link += "[Next](%02d.html)" % (filenumber + 1) unless filenumber &gt;= max_length
  return link
end

filenumber = 0
input = ARGF.read
chunks = input.split(SPLIT_MARKER)
# puts "Chunks length %d" % chunks.length
chunks.each do |chunk|

  next if chunk.length &lt; 1
  title = chunk.split("\n")[0]
  if filenumber == 0
    filename = "index.md"
  else
    filename = sprintf("%02d", filenumber) + ".md"
  end
  puts filename + ": " + title
  tf = File.new(filename, "w")
  tf.print chunk
  tf.puts
  tf.puts
  tf.puts make_link_line(filenumber, chunks.length - 1)
  tf.close
  filenumber += 1
end
```

I’ll factor out the filename creation the same way. Because I’m not as dumb as I look, I do that in two steps. First I create and use a `make_file_name` function by extracting the code as-is:

```ruby
def make_file_name(filenumber)
  if filenumber == 0
    filename = "index.md"
  else
    filename = sprintf("%02d", filenumber) + ".md"
  end
end
```

Now let’s improve that function:

```ruby
def make_file_name(filenumber)
  return "index.md" if filenumber == 0
  return sprintf("%02d.md", filenumber)
end
```
OK, that’s nice. Here’s the main code now:

```ruby
filenumber = 0
input = ARGF.read
chunks = input.split(SPLIT_MARKER)
# puts "Chunks length %d" % chunks.length
chunks.each do |chunk|

  next if chunk.length &lt; 1
  title = chunk.split("\n")[0]
  filename = make_file_name(filenumber)
  puts filename + ": " + title
  tf = File.new(filename, "w")
  tf.print chunk
  tf.puts
  tf.puts
  tf.puts make_link_line(filenumber, chunks.length - 1)
  tf.close
  filenumber += 1
end
```

Looking at this, we see half a dozen lines writing out the file. That should be factored out as well. And I am wondering: if we break the reference chunk off at the very beginning and cache it away in a variable, couldn’t we just append it during the main write, rather than in a second pass? It sure seems like we could. So I’ll factor out the writing and see what we get. A bit of polishing and we have this:

```ruby

def write_file(chunk, filenumber, max_length)
  filename = make_file_name(filenumber)
  title = chunk.split("\n")[0]
  puts filename + ": " + title
  tf = File.new(filename, "w")
  tf.print chunk
  tf.puts
  tf.puts
  tf.puts make_link_line(filenumber, max_length)
  tf.close
end

input = ARGF.read
chunks = input.split(SPLIT_MARKER)
filenumber = 0
chunks.each do |chunk|
  write_file(chunk, filenumber, chunks.length - 1) unless chunk.length &lt; 1
  filenumber += 1
end
```

Now that, I don’t mind saying, is a noticeable improvement. We’ll add the references in the next section.

</Text>
        </Document>
        <Document ID="79C006AA-0D08-4185-849B-31D8E06BDFF5">
            <Title>The compiled markdown</Title>
            <Text>I open the compiled markdown file in Sublime, my text editor, and it all looks pretty good, except that in addition to all the pictures showing up in line in the text, as they should, they are all at the bottom of the compiled file as well. It looks like this:

```
Just for grins, this is yet another sub-document, called Looking at compile. Here’s what the compile window looks like now:

![][ScreenShot2018-06-15at4.55.43AM]

Notice that the sub documents in the folder are called Sub-Section, just as we intended. That happened automatically, because of that structure setup we did. You can see that the Section Types are all shown in italic. That means they were automatically defined from structure. We could set them explicitly if we wanted to. But we don’t. I *would* like to see what the compiled text looks like right now, so I’ll let the compile go through.

[ScreenShot2018-06-15at3.48.45AM]: ScreenShot2018-06-15at3.48.45AM.png

[ScreenShot2018-06-15at3.56.55AM]: ScreenShot2018-06-15at3.56.55AM.png

[ScreenShot2018-06-15at3.59.33AM]: ScreenShot2018-06-15at3.59.33AM.png

[ScreenShot2018-06-15at4.15.13AM]: ScreenShot2018-06-15at4.15.13AM.png

[ScreenShot2018-06-15at4.31.51AM]: ScreenShot2018-06-15at4.31.51AM.png

[ScreenShot2018-06-15at4.33.00AM]: ScreenShot2018-06-15at4.33.00AM.png

[ScreenShot2018-06-15at4.34.19AM]: ScreenShot2018-06-15at4.34.19AM.png

[ScreenShot2018-06-15at4.35.50AM]: ScreenShot2018-06-15at4.35.50AM.png

[ScreenShot2018-06-15at4.53.51AM]: ScreenShot2018-06-15at4.53.51AM.png

[ScreenShot2018-06-15at4.55.43AM]: ScreenShot2018-06-15at4.55.43AM.png
```

That last bit, if compiled to HTML from Markdown, would look like a series of links to the PNGs. I’m not at all sure where that came from, but I’m not going to worry about it right now. 

No titles have come out as yet. Let’s deal with that just for fun.</Text>
        </Document>
        <Document ID="FB6A3F73-A6D8-42F0-9CC0-72ADFCD5EAB4">
            <Title>Post-Processing Built In</Title>
            <Text>Well, as predicted, I worked on plugging my splitter script into the Processing tab in my layout. What I wound up with was this:

#

You turn on the Post-process checkbox, then put the full path to the script in the Path field. I added the output redirect to test.txt as a check to see whether the build did the right thing. There’s surely a way to redirect STEDRR also but I didn’t look it up. Turns out if the script explodes. Scrivener detects that and pops up a window giving you the error.

And it did that, in two different ways. First, if you don’t get the path to the program right, you get a very obscure message:

￼

That wasn’t helpful, and I’ll be filing a bug report on it. But it was clear enough that it wasn’t finding my file, so I fiddled the address until it did.

The second message was an error message from inside the script, saying that the split operation had found illegal characters in the file. Since Scrivener displays the actual error message, you know where to look. But it turned out that if I executed the command manually, it worked, and when Scrivener executed it, it didn’t. That was confusing.

The message gave a small clue, saying that `split` had encountered a character that was illegal in US-ASCII. Now, I’m not clever enough to know that Ruby runs in UTF-8, and I still don’t know how UTF-8 characters got into the file but probably it’s something I typed. 

I thought at first that maybe Scrivener didn’t pass the output file name in, though the documentation said so. So I added a print statement to print the parameter. It was pages.md, as it should be. I wasn’t sure I had the right file, so I printed the length of the string read in.

Lo! and Behold! the length varied between when I ran it by hand and when Scrivener ran it. I searched for the error message using Google (always do that when confused) and I found something that referred to the file encoding. 

I printed the encoding when I ran it and when Scrivener ran it, and sure enough it was different. So I added one line:

`ARGF.set_encoding(Encoding::UTF_8)`

And it all began to work perfectly! Whew!

I renamed the folder where the real Pages live to end in `_mmd`, so that Scrivener would built the files correctly. I compiled directly to the real Pages folder, the script ran.

I did the usual

```
git status
git add -A
git commit -m “autogenerate works!”
git push
```

And the booklet showed up just as it should. I’ll do that right now, and you can read this Section. 

See you again soon!</Text>
        </Document>
        <Document ID="35F9141E-F285-4236-B130-6BE815DE8697">
            <Title>Compile Format</Title>
            <Text>### Compile Format

Here’s where the metaphorical rubber meets the virtual road. I’ve created a custom compile format, and it’s full of changes.

When I start a compile, it looks like this:

#

My special compile format is RJ GitHub, and the section types shown on the right are my special ones, *Section* and *Sub-Section*. We’ll come to those in a bit. There’s nothing special in the tags and replacement buttons at top right, but in the Settings (gear) I have some important items turned off:


￼

In particular, I wanted “Convert rich text to MultiMarkdown” turned off. The reason is that I type Markdown pound signs and other forms directly, and this check box escapes those, defeating my purpose. If you set up all the right rich text styles, you might want to go the other way. For now, I’m sticking with old school.</Text>
        </Document>
        <Document ID="CA364786-D880-46DB-ACDE-C856F5F2203F">
            <Title>Regrets, I've had a few</Title>
            <Text>Since I mentioned regrets, and since I always do “Programming in Public”, or in this case “Scrivening in Public”, here’s what’s on my mind. I’m going to start creating a few index cards on the cork board, to get a general idea of what might be in this little book. And it becomes clear right away that those ideas will fall into classifications, and some of them could be quite large.

For example, we may have some ideas about compiling to markdown. We may have some discussion about the details of layouts and prefixes and suffixes. We will surely talk about how to split the compiled document into bits, and we will probably do that manually at least once and then write a little script to do it and then embed that script into the Scrivener compilation.

I can imagine that this may mean that this little book will have sections, each section containing chapters, each chapter containing some kind of sub-documents like our current Sub-Sections. Maybe three levels instead of two.

We can change that setup at any time but it always seems best to get it right at the beginning, especially when we don’t know our way around the framework all that well. But I have enough experience with Scrivener to feel sure that we can’t get in too much trouble if we don’t do anything too radical. So we’ll let it ride. I do think I’ll create a folder and then test a compile.</Text>
        </Document>
        <Document ID="380C55A0-5078-44C9-A391-3515378FC7F6">
            <Title>Three Levels</Title>
            <Text>### Three or More Levels

I suspect when I next use Scrivener in earnest, I’ll go to three levels instead of the current two. I’ll have something like Section, Chapter, and Paragraphs. I don’t know, I’ll need better names but the idea will be to allow for major sections with identifiable formatting.

Sometimes in fiction chapters (especially), there’s another breakdown, often indicated by a little graphical widget in the text. If I wanted that I’m not sure if I’d do it with an additional level, or perhaps just a new layout. I just have an inkling that there’ll be more to do.

In fact, I’m typing in titles like the one above, which is a pretty clear indication that I have in mind more structure than is presently defined in my format and layouts.</Text>
        </Document>
        <Document ID="4DDC5CD8-0668-4277-BB38-3189AB612FFA">
            <Title>Scrivener Preferences</Title>
            <Text>### Scrivener Preferences

In Scrivener preferences, if I don’t mention it here, I have left it alone (or believe that I have).

### General

Under Saving, I have auto-save after 2 seconds. I didn’t have “Take snapshots”, but just checked it now, because why not.

I have no shared templates but that may change when I actually use this setup for something.

I have Automatic Quit set to 10 minutes, because I use Scrivener on both laptop and home machine, and the quit gives me a better chance of not having it open on the other computer. No good can come of having a project open on two computers, although Scrivener seems to handle it pretty well.

### Editing

Default text zoom: 150 because I have tiny little eyes.

### Behaviors

Double-Clicking is enabled, so that I can double click in the cork board mode and create a new card. I noticed that I seemed to have the habit of trying that, so I enabled it.

### Appearance

Under Scrivenings, I have “Show title in Scrivenings” enabled. I don’t use the Scrivenings mode often but when I do I prefer to see the titles.

### Corrections

I don’t think any of these are changed, but …

* Auto-Correction: Capitalize “i”, superscript ordinals, symbol and text substitutions
* Punctuation: Disable smart dashes
* Data-Detection: Automatically detect web addresses
* Auto-completion: all items checked

### Sharing

No changes, I think …

### Backup

Turn on auto backups, project close, before synching, compress, keep 5.</Text>
        </Document>
        <Document ID="88A585A7-E54D-4176-BECE-CB5EA4FA012C">
            <Title>Turn off Title and Author</Title>
            <Text>Mumble mumble how do we turn that off. I knew that yesterday or the day before …

#

Ah, yes. In the tags subtab of compile, it lists the metadata. Way down in the lower right, you can delete and add the stuff it includes. It’s basically putting YAML at the top of your compiled document. That’s actually something you might want on another day. Today is not that day. I’ll delete those items now:

￼

And sure enough, they’re gone from the top of the file. 

We could actually turn this into a GitHub Pages page right now. Maybe I’ll do that next. Right now, it’s time for a break. </Text>
        </Document>
        <Document ID="05D4F345-464F-4202-ADA6-9E3AFED5CA3B">
            <Title>Styles</Title>
            <Text>### Styles

Scrivener does allow you to use paragraph and font styles in your editor view, and has the ability to compile different output based on style. So in principle, at least, I could *italicize* the word “italicize” in my style, and have it compiled as \*italicize\*, so that it would show up in italics. 

I’m used to typing in plain text, and will probably stick with it, and I believe it might be difficult to set up otherwise. When I’ve set the mode in Scrivener that does that, it also escapes all my own markup, so I think I’d have to convert all the way. 

Possibly, there’s another way to do it, by associating a compiled form with any styling I used. That would take experimentation, and since I’m comfortable writing my own markup, I’ll probably keep doing it that way.

You might wish to go another way.</Text>
        </Document>
        <Document ID="FEA14C10-CE3E-4BB3-ADAB-0E655C52156E">
            <Title>System Preferences</Title>
            <Text>### System Preferences 

#

As you see here, I have most everything turned off. Most of that is just personal preference, though smart quotes may have caused me a little trouble in the transition from Scrivener to markdown to GitHub. 

I’ve also adjusted my preference for date formatting, because I’m using Scrivener’s placeholders for date and time up at the top of this booklet.

I think that’s all that I’ve touched.</Text>
        </Document>
        <Document ID="9AD27C8B-289B-4F3C-AB98-5DE97D8E0A88">
            <Title>Image References Alternative</Title>
            <Text>The ever-marvelous AmberV (Ioa Petra'ka)  on the Scrivener forum pointed me to §21.4.1 in the manual, an alternate way of putting images into the text. I’ll try it here.

![A picture of me working right now[(arbitrary)

I found §21.4.1 a bit confusing. For me, what worked was this:

1. If the desired image isn't already in the binder, add it using (idk) Gear &gt; Add &gt; Existing Files. It will show up in Research.
2. Create a conventional Markdown image link where you want the picture to appear, Put anything in the parenthesized place where the image file will go: ![Your image text](anything)).
3. Select the text in the parens. (_anything_).
4. From the binder, hold Option and drag the image into the editor. The text (anything) will be replaced at compile time with the exported file name of the image. (Trust us on this.)

As you can see, if there’s an image up there, it works. What’s less desirable is that the image isn’t visible to me when I’m editing, as are all my others. So I’m going to go ahead with the “improvements” to the Ruby program. We’ll discuss that in the next section.</Text>
        </Document>
        <Document ID="23216A60-1DB4-44BC-B71F-0E54506C4510">
            <Title>splitter</Title>
            <Text>### Splitter

Here’s a current copy of splitter, the one used to publish this version:

```ruby
#!/usr/bin/ruby
require 'tempfile'

SPLIT_MARKER = "----\n\n"
TOC_MARKER = "&lt;!--TOC--&gt;\n"
Titles = {}

def add_toc(chunk)
  halves = chunk.split(TOC_MARKER)
  puts "halves length %d" % halves.length
  return chunk if halves.length != 2
  return halves[0] + table_of_contents + halves[1]
end

def make_file_name(filenumber)
  return "index.md" if filenumber == 0
  return sprintf("%02d.md", filenumber)
end

def make_link_line(filenumber, max_length)
  link = ""
  link += "[%s](%02d.html) | " % [Titles[filenumber - 1], filenumber - 1] unless filenumber == 0
  link += "[Top](index.html) | "
  link += "[%s](%02d.html)" % [Titles[filenumber + 1], filenumber + 1] unless filenumber &gt;= max_length
  return link
end

def record_titles(chunks)
  filenumber = 0
  chunks.each do | chunk |
    title = chunk.split("\n")[0]
    Titles[filenumber] = title.strip[2..-3]
    filenumber += 1
  end
end

def table_of_contents
  toc = ""
  Titles.each_pair do | number, title |
    # toc += "* [" + title + "](" + make_file_name(number) + ")\n" 
    toc += "* [%s](%s)\n" % [title, make_file_name(number)] 
  end
  return toc
end

def update_table_of_contents(chunks)
  toc_chunk = chunks.delete_at(0)
  updated_toc = add_toc(toc_chunk)
  chunks.insert(0, updated_toc)
end

def write_file(chunk, reference_chunk, filenumber, max_length)
  filename = make_file_name(filenumber)
  title = Titles[filenumber]
  puts filename + ": " + title
  tf = File.new(filename, "w")
  tf.print chunk
  tf.puts
  tf.puts
  tf.puts make_link_line(filenumber, max_length)
  tf.puts
  tf.puts
  tf.print reference_chunk
  tf.puts
  tf.puts
  tf.close
end

def write_files(chunks, reference_chunk)
  filenumber = 0
  chunks.each do |chunk|
    write_file(chunk, reference_chunk, filenumber, chunks.length - 1) unless chunk.length &lt; 1
    filenumber += 1
  end
end

ARGF.set_encoding(Encoding::UTF_8) 
input = ARGF.read
chunks = input.split(SPLIT_MARKER)
reference_chunk = chunks.delete_at(-1)
record_titles(chunks)
update_table_of_contents(chunks)
write_files(chunks, reference_chunk)
```</Text>
        </Document>
        <Document ID="9DE2E682-4F2D-4320-B948-B9A9405E2F81">
            <Title>Spaces after titles</Title>
            <Text>### Spaces after titles

I discovered that when Scrivener is rendering folder titles, they are compiled as “# Title #  “, with two trailing spaces, while documents are compiled as “# Title #”, with no spaces. 

I modified the splitter script to say

`Titles[filenumber] = title.strip[2..-3]`

rather than

`Titles[filenumber] = title[2..-3]`

Note: This subsequently turned out to be an anomaly in how I had defined my layouts. The settings in the TL;DR section are correct as of this writing.</Text>
        </Document>
        <Document ID="8FAC3C40-8FE1-431D-8DDE-B6D9024B0DA2">
            <Title>intro</Title>
        </Document>
        <Document ID="CB4262FF-B23C-4340-8E28-9DCC355355D1">
            <Title>ToC and Pages</Title>
            <Text>It’s about time to think more seriously about breaking this little book up into pages, setting up a Table of Contents, and inter-page linking. As in all things, I’ll think about this broadly and try to go about it incrementally.

### Splitting

I’ve decided to split this little book into separate HTML files, one per Section. (We’ll describe below just what a Section is, but for now, it’s basically a chapter.) Scrivener can help with this to a degree: you can get it to put a special separator line between each section. What it won’t do is close a section file and automatically open a new one.

So the plan is to write a little script, probably in Ruby, to read our one big file, and create a bunch of little files.

### Titles

Right now, I’m using page titles in Scrivener, and I intend to compile them into the final documents. The alternative would be to type the title explicitly into each “chapter/page”, but I thought Scrivener can do this, why not try it. 

### ToC

So our Table of Contents might want to look like this:

1. Introduction
2. Style, Scriveners and Mine
3. Starting the Project

Each of those lines would, of course, be a link to the page with that chapter in it. (Or, if it’s all compiled together as one big page, which I am sure I don’t like from the samples I’ve already made, they could be links to anchors.)

Scrivener isn’t much help with this. It can build a table that includes calculated page numbers, but that’s only useful in the one big file mode, so it’s not for us.

I’ve found a way to get a list of titles as plain text lines, and I’ve even mangled one of those into a list of links using Sublime and a bunch of regexes. That wasn’t fun.

### Page Names

I can see two basic approaches to the page names. The top surely needs to be called `index`, but the others could be named like the page titles, or simply numerically. We have the titles, and they’ll be at the top of every page, so we can use them if we wish.

But is there any real advantage to me or to the reader between a file named 09.html and testing-the-compile.html? I’m not sure. Likely I’ll start with numeric ones and see what I think later.

### Anchors

I happen to know that GitHub does something fancy with headings, H2 and the like. If you have a heading “\#\#\# Page Names”, GitHub’s Jekyll conversion will add an HTML anchor of “page-names” to its HTML. That might come in handy, but seems more useful if we *don’t* make pages than if we do.

In any case, I think our next step has to be splitting the file and getting the initial split version up on GitHub. Grr. Writing is easier.</Text>
        </Document>
        <Document ID="DCF9E731-2FAC-401F-8994-A4B5A55FF2F6">
            <Title>Layout Assignments</Title>
            <Text>### Layout Assignments

We assign a section layout to each section type in Scrivener. There’s a button at the bottom of the middle section of the compile panel that says “Assign Section Layouts” and, well, that’s what it does. It opens another panel looking like this:

#

I have “Section” assigned to “Use Section w/ Sep, Heading Text, and “Sub-Section” is assigned to “Use SubSection”. (I often name things that are intended to be “used” with the word “Use” in their name, as a reminder.)

I believe that if I were to assign “As-Is” to “Sub-Section” it would probably also work, but “Use SubSection” is what I’m using and I’m sticking to it.</Text>
        </Document>
        <Document ID="B9587831-FE9D-4EB8-87CC-2D151C48624E">
            <Title>Assessing Where We Are</Title>
            <Synopsis>In this section, we look at where we’ve been, and where we might want to go.</Synopsis>
            <Text>Everything seems to be working. That means it’s a good moment to look at what we have, in this booklet, and in our Scrivener setup. It’s a good moment to decide whether we’re done for now, what we wish we had done, and what we might want to do right now.

Leonardo supposedly said “Art is never finished, only abandoned”. Probably he said it in Italian, I suppose. Anyway, it’s the same with a program, a set of web pages, or a Scrivener setup. Sometimes we stop, but it’s never really finished. And right now, I’m pretty sure there’s more to do.

### Summary TL;DR

Of all the things we might do, this seems most valuable to me. Let’s put a “Too Long; Didn’t Read” summary in the booklet, summing up all the settings and changes I’ve made, without so much intervening narrative. That seems to me to be a decent service for people who just want to *git ‘er done* rather than read a story. 

That won’t be much fun, but it’ll probably be worth doing.

### Booklet Organization

My Scrivener binder is organized into only two levels, section, and sub-section. The sections get headings, and the subs do not. I can sense a larger level of organization trying to come into being here. Something like section, chapter (or web page really), and sub-page.

It might be worth making that change for this booklet.

### Synopses

Scrivener’s index cards have a title, which is the same as the title in the binder, and a synopsis, the text written on the card. I have a vague idea that I’d like to use the synopsis as a leading quote on the pages, because in something I wrote, ages ago, I put something like that at the heading of each chapter.

Of course I could just type them in. And there is a Scrivener “placeholder” that will pull the Synopsis in wherever you want it. I’ll put this card’s synopsis here:

&gt;&lt;$synopsis&gt;

### Embedded Links

Commonly in writing something like this booklet, you want to refer to some other part of the text. On the internet, of course, we’d want a link to the actual page and paragraph. Scrivener does support this kind of thing, and they’ll act as links in a single web page or PDF (I believe). Clearly they wouldn’t work once we split up the file, because Scrivener doesn’t know we’re going to do that. 

We might want to figure out a way to support those links. If we do, the most interesting bit will be finding the right reference in Scrivener’s big dump of references, and converting it to work with our structure. I think this would turn out to be challenging. One could do a lot of links by hand before paying for this feature, but it’s tempting to at least look into it.

### Other Embeddings

There might be other kinds of embeddings we’d want to do. If we do go to a three-level structure, we might want to put a table of contents for each section at the top of that section. To do that, we’d put a marker wherever the little ToC would go, and we’d need to scan each chunk to see if it needed something embedded in it. 

It’s “easy to see” that the same approach we used for the big ToC could be used for any other kind of embedding. They would all have the same structure:

* split the chunk on the desired marker
* if the chunk doesn’t split, do nothing
* otherwise change the chunk to first part, embedded part, last part

We’d repeat that process until the chunk didn’t split, I suppose. Anyway it seems straightforward.

My style of programming discipline says to build that when I need it, not to build it on speculation. Embedded links might be the opportunity, if I choose to do it.

### Conclusion - for now

It seems clear to me that the *TL;DR* chapter is worth doing. Maybe I’ll start that today, maybe tomorrow. Maybe never: no promises. Stay tuned!</Text>
        </Document>
        <Document ID="0787D095-745C-407C-B901-68D68C3F3DD9">
            <Title>Better Links</Title>
            <Text>I decided to improve the links between articles, just because I could. Let me make a few quick points though.

First, improving the links is probably not the most valuable new feature for building this booklet. Contenders for most important include automating the creation of the table of contents, which I am making entirely by hand, and fully automating the splitting process. And those things might be more valuable to you, the reader as well.

Second, with the making of links so nicely factored out into a separate method, improving their formatting became very simple. So, with a few minutes in the afternoon to do something, I chose to do that. I’ll do the harder things when I have more time and ability to concentrate.

Third, doing the links prepares us for the somewhat trickier job of creating the table of contents, so it’s a step in an important direction.

Anyway, here’s what I did:

The fundamental idea is that I was already extracting the title of each section, which I was printing as I wrote the file, with this code in `write_file`:

```ruby
  title = chunk.split("\n")[0]
  puts filename + ": " + title
```

So it made some sense to save the titles in a little Hash, by file number, and then print them in the `make_link_line` function. That almost went as planned. Almost. My first attempt just saved the titles in the Hash as we processed, in `write_file`, which called `make_link_line`, which used the Hash. That nearly worked, except that `make_link_line` needs to know the title for the *next* article, which hasn’t been read in yet.

No problem,  just do two passes through the chunks, one to build the titles, and one to write the files. First I’ll show you the bits, then save the whole script here for you.

The main looks like this now:

```ruby
input = ARGF.read
chunks = input.split(SPLIT_MARKER)
reference_chunk = chunks.delete_at(-1)
filenumber = 0
chunks.each do | chunk |
  title = chunk.split("\n")[0]
  Titles[filenumber] = title[2..-3]
  filenumber += 1
end
filenumber = 0
chunks.each do |chunk|
  write_file(chunk, reference_chunk, filenumber, chunks.length - 1) unless chunk.length &lt; 1
  filenumber += 1
end
```

You can see the two passes, one saving titles, and one writing out the files. Writing the file is still a bit odd, because it gets the title again and it need not. I just noticed that fact now:

```ruby
def write_file(chunk, reference_chunk, filenumber, max_length)
  filename = make_file_name(filenumber)
  title = chunk.split("\n")[0]
  puts filename + ": " + title
  tf = File.new(filename, "w")
  tf.print chunk
  tf.puts
  tf.puts
  tf.puts make_link_line(filenumber, max_length)
  tf.puts
  tf.puts
  tf.print reference_chunk
  tf.puts
  tf.puts
  tf.close
end
```

I can replace that `title =` line with a reference to the Hash, and I’ll do that right now: 

`  title = Titles[filenumber]`

This works fine, with the surprising result that the trace now shows the titles without the hash marks around them that used to be printed. Why? Because we create the Titles Hash with this:

`Titles[filenumber] = title[2..-3]`

Which removes the “# “ and “ #” from the beginning and end of the title line as compiled by Scrivener. Anyway, that’s super. The new `make_link` looks like this:

```ruby
def make_link_line(filenumber, max_length)
  link = ""
  if filenumber &gt; 0
    link += "[%s](%02d.html) | " % [Titles[filenumber - 1], filenumber - 1]
  end
  link += "[Top](index.html) | "
  link += "[%s](%02d.html)" % [Titles[filenumber + 1], filenumber + 1] unless filenumber &gt;= max_length
  return link
end
```

That’s cleaned up a bit from the previous version, which had gotten a bit crufty as I hammered it into submission. Here we see, as we always do, that even with the best of will, code tends to deteriorate, and it’s valuable to improve it when we see a chance. 

One other neat thing happened. You’ll notice I interpolated vertical bars between the links. They didn’t really stand out from each other without the bars, so I was envisioning a link line like

“Setting up the project \| Top \| Splitting”

But what I got was this:

Setting up the project | Top | Splitting

This happens because Scrivener correctly compiles the Markdown notation for tables, which is to put things between vertical bars. I had forgotten that entirely, but I certainly like the result.

So, without further ado, here’s the current version of the Ruby script. After putting it here, I’ll update the table of contents and push the booklet to GitHub Pages. Later today (it’s 5 AM just now) I’ll work on whatever I decide to do next.

```ruby
#!/usr/bin/env ruby -wU
require 'tempfile'

SPLIT_MARKER = "----\n\n"
Titles = {}

def make_file_name(filenumber)
  return "index.md" if filenumber == 0
  return sprintf("%02d.md", filenumber)
end

def make_link_line(filenumber, max_length)
  link = ""
  if filenumber &gt; 0
    link += "[%s](%02d.html) | " % [Titles[filenumber - 1], filenumber - 1]
  end
  link += "[Top](index.html) | "
  link += "[%s](%02d.html)" % [Titles[filenumber + 1], filenumber + 1] unless filenumber &gt;= max_length
  return link
end

def write_file(chunk, reference_chunk, filenumber, max_length)
  filename = make_file_name(filenumber)
  title = Titles[filenumber]
  puts filename + ": " + title
  tf = File.new(filename, "w")
  tf.print chunk
  tf.puts
  tf.puts
  tf.puts make_link_line(filenumber, max_length)
  tf.puts
  tf.puts
  tf.print reference_chunk
  tf.puts
  tf.puts
  tf.close
end

input = ARGF.read
chunks = input.split(SPLIT_MARKER)
reference_chunk = chunks.delete_at(-1)
filenumber = 0
chunks.each do | chunk |
  title = chunk.split("\n")[0]
  Titles[filenumber] = title[2..-3]
  filenumber += 1
end
filenumber = 0
chunks.each do |chunk|
  write_file(chunk, reference_chunk, filenumber, chunks.length - 1) unless chunk.length &lt; 1
  filenumber += 1
end
```</Text>
        </Document>
        <Document ID="B1821DDE-BB37-4E11-B4B4-96C40F11AF30">
            <Title>Forum Links</Title>
            <Text>### Forum Links

Here are links to entries on the excellent Scrivener forum, addressing some of the issues I’ve had, including most of those mentioned here:

* [Trailing Spaces in Title Header on Folders Only](https://www.literatureandlatte.com/web/forum/viewtopic.php?f=2&amp;t=52556)
* [Creating a GitHub Pages "booklet" using Scrivener](https://www.literatureandlatte.com/web/forum/viewtopic.php?f=19&amp;t=52509)
* [Compiling To LaTeX -- One file per section?](https://www.literatureandlatte.com/web/forum/viewtopic.php?f=2&amp;t=52114)
* [Can MMD compile folder and file name extension differ? Or even the names?](https://www.literatureandlatte.com/web/forum/viewtopic.php?f=2&amp;t=52488)
* [Compiling vanilla MMD, can't get rid of title?](https://www.literatureandlatte.com/web/forum/viewtopic.php?f=2&amp;t=52451)

There are other topics I’ve created or spoken to. You can search the forum for my name to find them, but the above are the ones that seem to me to be of the most potential interest.</Text>
        </Document>
        <Document ID="F21B5FD4-C532-4B70-B694-FDE6EA896FAD">
            <Title>Image References Fail</Title>
        </Document>
        <Document ID="A94AE0D5-4244-44D6-8C50-AC493474D442">
            <Title>Style, Scrivener's and Mine</Title>
            <Text>Scrivener allows you–indeed encourages you–to use paragraph and font styles. You can style your headers, indent your paragraphs, show text in bold or italic, just about anything you’d like to do. Its approach has two advantages at least.

First of all, you can lay out your work any way you wish, so that its screen appearance is whatever works best for you as you write. You can have a plain typewriter look, or a fully formatted finalized kind of look.

Second, Scrivener does a good job of exporting your style information to whatever publication format you may choose, and that’s quite a few formats:

#

Now, when I used to do all my writing in Microsoft Word (ptui!), I used styles extensively. Basically I created my document in the form it was going to have on paper. (We used paper a lot in those days. Most of you have probably at least heard of paper.)

Now, most everything I write is published on the Internet, and I write directly in Markdown, where you use printable characters to indicate style. If I want a word to be italicized, I enclose it in stars, like this: \**bold*\*, and so on. In other words, I write in plain text, with a simple visible formatting syntax.

As I work with Scrivener, I may find it useful to use its styles, and to figure out how to make them export to my publication format. I’m going to begin, however, in plain text.

In what follows, we’ll start with Scrivener in its default mode, and I’ll show you all the changes I make to get it to do what I want. I’m going to try to make minimal changes rather than run wildly through Scrivener’s carefully-planned defaults. With luck, that will leave me in a position to move closer to Scrivener’s center as time goes on.</Text>
        </Document>
        <Document ID="C5543293-89F6-4A6B-9978-F8E297148D7B">
            <Title>Prev, Top, Next</Title>
            <Text>There has been a great public outcry for links between the pages. Well, Brian Kelly, @spilth on Twitter, mentioned it. I told him to cool his jets, we’re only on version 0.0.1 or something but he called me on the “feedback welcome” typo I made in my initial announcement.

But it does seem to me that we should be able to put in some quick links with the new little splitter Ruby script. I’m going to break my own rules again, and not TDD this. Hold my beer.

```
#!/usr/bin/env ruby -wU
require 'tempfile'

SPLIT_MARKER = "----\n\n"

filenumber = 0
input = ARGF.read
chunks = input.split(SPLIT_MARKER)
# puts "Chunks length %d" % chunks.length
chunks.each do |chunk|

  next if chunk.length &lt; 1
  title = chunk.split("\n")[0]
  if filenumber == 0
    filename = "index.md"
  else
    filename = sprintf("%02d", filenumber) + ".md"
  end
  puts filename + ": " + title
  tf = File.new(filename, "w")
  tf.print chunk
  link = ""
  if ( filenumber == 1 ) 
    link += "[Prev](index.html) "
  elsif filenumber &gt; 1
    link += "[Prev](%02d.html) " % (filenumber - 1) unless filenumber == 0
  end
  link += "[Top](index.html) "
  link += "[Next](%02d.html)" % (filenumber + 1) unless filenumber &gt;= chunks.length - 1
  tf.puts
  tf.puts
  tf.puts link
  tf.close
  filenumber += 1
end
```

This is pretty rough, but it seems to work. A side lesson, though: when you don’t work to get your code clean, it winds up getting dirtier all the time. But now we have links between pages.</Text>
        </Document>
        <Document ID="B0F6169B-7910-401F-83A1-C3577549ED31">
            <Title>Styles</Title>
            <Text>Scrivener lets you assign “Styles” to paragraphs, and you can control how those styles get compiled into the output. So, in principle, I could set up a “Heading 2” style such that when I format a paragraph with Heading 2, it would look different in my editor, and (I believe) I could make it compile with the ## in front of it that signify H2 to Markdown. For now, I’m not going to do that: I’m going to type my own Markdown marks, because I’m used to it.

Perhaps we’ll come back to the topic of styles, for now, let’s move on …</Text>
        </Document>
        <Document ID="6A131501-9D17-4CF8-8C14-29021DAF6DFA">
            <Title>Titles</Title>
            <Text>To get the titles to come out, we need to do a bit of layout assignment. I think maybe we don’t need to create new layouts yet, we might just be able to tick some options. Let’s try, inside compile:

#

There’s already a layout defined, Text Section with Heading, that nearly does the job. I notice it’s using H1 (one # sign), but maybe that’s OK. Now the compiled Markdown looks like this:

```
Title: GitHub-Pages  
Author: Ronald Jeffries

# Initial Notes #

We’re here to create a little “book”, showing how to create the GitHub pages you will be reading when this is all done. This chapter starts at the beginning, though it may not wind up being the first page of the “book”.

I’ve just started with a blank Scrivener project, which I named “GitHub-Pages” and saved in Dropbox/Apps/Scrivener, where my shared Scrivener projects live.

Right now, what I see on the screen looks like this:

![][ScreenShot2018-06-15at3.48.45AM]

I’ve got View &gt; Text Editing &gt; Show invisibles turned on right now. That’s making the paragraph markers and dots for spaces show up. I don’t usually have that on but wanted to talk about the defaults set so far.

I’m going to compile from Scrivener to MultiMarkdown, which is its compile form intended to produce, well, MultiMarkdown, which will be roughly what GitHub expects to make our pages. And although Scrivener lets you format your typing any way you like, and although we may play with that capability later on, I’m used to typing in a sans-serif font (presently Arial) with explicit returns between paragraphs. I’ve got Scrivener’s default formatting set up that way.

# Default Formatting #

You set your initial font and paragraph info in Scrivener &gt; Preferences, (command-comma). My info looks like this:
```

And so on. I notice it has included Title and Author at the top. There’s a way to turn that off, and I’d like to do that while I’m thinking about it.</Text>
        </Document>
        <Document ID="6DCE7F6E-B59C-44D5-A098-1DE87DB75231">
            <Title>Turn off Title and Author</Title>
        </Document>
        <Document ID="6D14F463-333D-4F6E-A7C1-E738579705F0">
            <Title>Thoughts on Improvements</Title>
            <Text>
Just as an experiment, I’ve put some text inside the folder that defines this section of thoughts. I did it by typing in the Scrivenings mode, though there are other ways of doing it, I’m sure. I expect that it’ll compile just fine and this will show up as an introductory paragraph in this (big) section.

In the binder, the folder icon is now showing a little text indicator so that I can be aware there’s text in here.

#</Text>
        </Document>
        <Document ID="9030CC8B-7B64-4E8B-A342-2FD010CC5A9D">
            <Title>Image References</Title>
            <Text>Here I am at the coffee shop. My cunning plan is to add a suffix line to the end of the whole file, which will look to our Ruby code like just another separator. Then, after chunking the file, the last chunk should be the references. I’ll remove the last chunk from the array, saving it elsewhere, and as I loop through the remaining chunks, I’ll append the reference chunk.

This should be a piece of cake. First the suffix. I think that’s in the compile format. Sure enough, here’s what I did:

#

Then I ran my splitter to see that it is currently producing files up to 16.md. Once I compile this, it should go to 17 (and probably with a useless title because there won’t be one). Here goes a compile …

Ha ha, jokes on me, it got 18, because before I compiled, this section wasn’t in there either. So it looks good so far. The last file broken out looks like this:

```
[ScreenShot2018-06-17at5.43.41AM]: ScreenShot2018-06-17at5.43.41AM.png

[ScreenShot2018-06-15at3.48.45AM]: ScreenShot2018-06-15at3.48.45AM.png

[ScreenShot2018-06-15at3.56.55AM]: ScreenShot2018-06-15at3.56.55AM.png

… (and so on)

[Prev](17.html) [Top](index.html) 
```

OK, looks good. Now to fiddle the Ruby script. [A few moments pass …] Ah, and here it is:

```ruby
#!/usr/bin/env ruby -wU
require 'tempfile'

SPLIT_MARKER = "----\n\n"

def make_file_name(filenumber)
  return "index.md" if filenumber == 0
  return sprintf("%02d.md", filenumber)
end

def make_link_line(filenumber, max_length)
  link = ""
  if ( filenumber == 1 ) 
    link += "[Prev](index.html) "
  elsif filenumber &gt; 1
    link += "[Prev](%02d.html) " % (filenumber - 1) unless filenumber == 0
  end
  link += "[Top](index.html) "
  link += "[Next](%02d.html)" % (filenumber + 1) unless filenumber &gt;= max_length
  return link
end

def write_file(chunk, reference_chunk, filenumber, max_length)
  filename = make_file_name(filenumber)
  title = chunk.split("\n")[0]
  puts filename + ": " + title
  tf = File.new(filename, "w")
  tf.print chunk
  tf.puts
  tf.puts
  tf.puts make_link_line(filenumber, max_length)
  tf.puts
  tf.puts
  tf.print reference_chunk
  tf.puts
  tf.puts
  tf.close
end

input = ARGF.read
chunks = input.split(SPLIT_MARKER)
reference_chunk = chunks.delete_at(-1)
filenumber = 0
chunks.each do |chunk|
  write_file(chunk, reference_chunk, filenumber, chunks.length - 1) unless chunk.length &lt; 1
  filenumber += 1
end
```

It went as planned, oddly enough. Remove and save the last chunk, pass it into the write_file function, and append it, with a few return characters, to each chunk as we write it out.

I’m calling that done. For now, I’ll update the table of contents, which is still done manually, then compile this all one more time, split it up, and move it into the real project, commit, and push.

To come: set up this post processor to run automatically, and aim the whole thing at the real folder, assuming Git will let me rename the top folder to be `something_mmd`. If not, regroup.

After that, maybe table of contents and improving the inter-article links. See you soon!</Text>
        </Document>
        <Document ID="D414D0C7-7152-474B-A235-34243E7D15EE">
            <Title>Created the folder</Title>
            <Text>I’ve created a folder, called Testing the Compile, and this document inside it, called Created the folder. In our final compilation, we’ll want the title of the folder to show up and not the title of this document. Now I’ll add one more document, to better test our Sub-Section notion.</Text>
        </Document>
    </Documents>
</SearchIndexes>